var TsAlgorithms=(()=>{var c=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames;var y=Object.prototype.hasOwnProperty;var G=(t,r)=>{for(var n in r)c(t,n,{get:r[n],enumerable:!0})},f=(t,r,n,a)=>{if(r&&typeof r=="object"||typeof r=="function")for(let e of V(r))!y.call(t,e)&&e!==n&&c(t,e,{get:()=>r[e],enumerable:!(a=g(r,e))||a.enumerable});return t};var k=t=>f(c({},"__esModule",{value:!0}),t);var E={};G(E,{createGraph:()=>v,createGraphEdge:()=>x,createGraphVertex:()=>u});function u(t,r){return{value:t,key:r(t)}}function x(t,r,n=0){return{startVertex:t,endVertex:r,weight:n}}function v(t=!1){let r=[],n=[];return Object.freeze({isDirected:t,get vertices(){return r},get edges(){return n},createGraphEdge:x,createGraphVertex:u,addVertex(e){let s=this.getVertex(e.key);return s?(s.value=e.value,this):(r.push(e),this)},getVertex(e){return r.find(s=>s.key===e)},addEdge(e){return this.addVertex(e.startVertex).addVertex(e.endVertex).edges.push(e),this},neighbors(e){return this.edges.filter(s=>s.startVertex===e||s.endVertex===e)},toJSON(){let{isDirected:e}=this,s=r.map(p=>{let{key:h,value:d}=p;return{key:h,value:d}}),i=n.map(p=>{let{startVertex:h,endVertex:d,weight:o}=p;return{start:h.key,end:d.key,weight:o}});return{isDirected:e,vertices:s,edges:i}}})}return k(E);})();
